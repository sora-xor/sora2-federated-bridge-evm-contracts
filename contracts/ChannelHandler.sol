// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.15;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./interfaces/IChannelHandler.sol";
import {InvalidPeersCount, InvalidLength, InvalidNonce, InvalidSignature, InsufficientGas, AlreadyRegistered, Unregistered, InvalidCaller, LastPeer, SignaturesNotEnough, SigParamsLengthMismatch} from "./Error.sol";

/**
 * @dev The contract was analyzed using Slither static analysis framework. All recommendations have been taken
 * into account and some detectors have been disabled at developers' discretion using `slither-disable-next-line`.
 */
contract ChannelHandler is Ownable, ReentrancyGuard, IChannelHandler {
    using ECDSA for bytes32;

    /// @dev the last submitted message nonce
    uint112 public messageNonce;
    /// @dev the last submitted batch nonce
    uint112 public batchNonce;
    /// @dev number of authorized peers
    uint32 public peersCount;
    /// @dev indicates whether address is an authorized peer
    mapping(address => bool) public isPeer;
    /// @dev indicates whether address is an authorized app
    mapping(address => bool) public isApp;
    /// @dev temporary storage for tracing uniq signers of the batch
    mapping(address => bool) public signedPeers;

    uint256 public constant GAS_BUFFER = 60000;
    bytes2 constant ADD_PEER_CALL = 0x0101;
    bytes2 constant REMOVE_PEER_CALL = 0x0102;

    constructor() {}

    /// @dev Once-off post-construction call to set initial configuration.
    function initialize(address[] calldata initialPeers) external onlyOwner {
        for (uint256 i; i < initialPeers.length; i++) {
            addPeer(initialPeers[i]);
        }
        isApp[address(this)] = true;
        // drop admin privileges
        renounceOwnership();
    }

    function submit(
        Batch calldata batch,
        uint8[] calldata v,
        bytes32[] calldata r,
        bytes32[] calldata s
    ) external nonReentrant {
        uint256 begin_gas_left = gasleft();
        if (peersCount < 1) revert InvalidPeersCount();
        if (batch.messages.length >= 256) revert InvalidLength();
        batchNonce = batchNonce + 1;
        // Check batch nonce is correct for replay protection
        if (uint112(batch.nonce) != batchNonce) revert InvalidNonce();

        // Since we verify that the batch was generated by substrate, we can safely
        // assume that all fields are correct (for example, `max_gas` are
        // appropriate, and `total_max_gas` = `sum(max_gas)`)

        bytes32 commitment = keccak256(abi.encode(batch));
        bytes32 digestHash = keccak256(abi.encode(block.chainid, commitment));

        if (!verifySignatures(digestHash, v, r, s)) revert InvalidSignature();
        // Require there is enough gas to execute all messages
        if (gasleft() < batch.total_max_gas + GAS_BUFFER)
            revert InsufficientGas();

        uint256 results = processMessages(batch.messages);

        uint256 gas_used = begin_gas_left - gasleft();

        emit BatchDispatched(
            batchNonce,
            msg.sender,
            results,
            batch.messages.length,
            gas_used,
            block.basefee
        );
    }

    function submitMessage(bytes calldata payload) external {
        if (!isApp[msg.sender]) revert Unregistered();
        messageNonce = messageNonce + 1;
        emit MessageDispatched(msg.sender, messageNonce, payload);
    }

    function addPeerByPeer(address newPeerAddress) external returns (bool) {
        if (msg.sender != address(this)) revert InvalidCaller();
        addPeer(newPeerAddress);
        emit ChangePeers(newPeerAddress, false);
        bytes memory call = abi.encodePacked(ADD_PEER_CALL, newPeerAddress);
        this.submitMessage(call);
        return true;
    }

    function registerApp(address newApp) external returns (bool) {
        if (msg.sender != address(this)) revert InvalidCaller();
        if (isApp[newApp]) revert AlreadyRegistered();
        isApp[newApp] = true;
        return true;
    }

    function removeApp(address app) external returns (bool) {
        if (msg.sender != address(this)) revert InvalidCaller();
        if (!isApp[app]) revert Unregistered();
        isApp[app] = false;
        return true;
    }

    function removePeerByPeer(address peerAddress) external returns (bool) {
        if (msg.sender != address(this)) revert InvalidCaller();
        removePeer(peerAddress);
        emit ChangePeers(peerAddress, true);
        bytes memory call = abi.encodePacked(REMOVE_PEER_CALL, peerAddress);
        this.submitMessage(call);
        return true;
    }

    /**
     * @dev Adds new peer to the list of signature verifiers.
     * @dev Private function
     * @param newAddress address of new peer
     */
    function addPeer(address newAddress) private {
        if (isPeer[newAddress]) revert AlreadyRegistered();
        isPeer[newAddress] = true;
        ++peersCount;
    }

    /**
     * @dev Removes a peer from the list of signature verifiers.
     * @dev Private function
     * @param peerAddress address of the peer
     */
    function removePeer(address peerAddress) private {
        if (!isPeer[peerAddress]) revert Unregistered();
        isPeer[peerAddress] = false;
        if (--peersCount < 1) revert LastPeer();
    }

    /**
     * @dev Checks given addresses for duplicates and if they are peers signatures
     * Batch nonce should be unique
     * @param hash signed data
     * @param v v-component of signature from hash
     * @param r r-component of signature from hash
     * @param s s-component of signature from hash
     * @return true if all given addresses are correct or false otherwise
     */
    function verifySignatures(
        bytes32 hash,
        uint8[] memory v,
        bytes32[] memory r,
        bytes32[] memory s
    ) private returns (bool) {
        uint256 signatureCount = v.length;
        if (signatureCount != r.length || signatureCount != s.length)
            revert SigParamsLengthMismatch(signatureCount, r.length, s.length);
        uint256 needSigs = peersCount - (peersCount - 1) / 3;
        if (signatureCount < needSigs) revert SignaturesNotEnough();

        uint256 count;
        address[] memory recoveredAddresses = new address[](signatureCount);
        for (uint256 i; i < signatureCount; ++i) {
            address recoveredAddress = hash.toEthSignedMessageHash().recover(
                v[i],
                r[i],
                s[i]
            );

            // not a peer address or not unique
            if (!isPeer[recoveredAddress] || signedPeers[recoveredAddress]) {
                continue;
            }
            recoveredAddresses[count] = recoveredAddress;
            unchecked {
                count = count + 1;
            }
            signedPeers[recoveredAddress] = true;
        }

        // restore state for gas refund
        for (uint256 i; i < count; ) {
            signedPeers[recoveredAddresses[i]] = false;
            unchecked {
                ++i;
            }
        }

        return count >= needSigs;
    }

    /** 
     * @dev Processes messages by executing a call with payload on a target address
     * @dev Verifies if each target address is a trusted app
     * @param messages Array of message structs - {check IBatch interface}
     * @return results Encoded bitmap of execution statuses, up to 256 messages
     */
    function processMessages(
        Message[] calldata messages
    ) private returns (uint256 results) {
        for (uint256 i = 0; i < messages.length; ++i) {
            // Deliver the message to the target
            // Delivery will have fixed maximum gas allowed for the target app
            bool success = false;
            if (isApp[messages[i].target]) {
                (success, ) = messages[i].target.call{
                    value: 0,
                    gas: messages[i].max_gas
                }(messages[i].payload);
            }
            results |= uint256(success ? 1 : 0) << i;
        }
        return results;
    }
}
